// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.Collections.Immutable;
using System.Text;
using Elastic.Mapping.Generator.Model;

namespace Elastic.Mapping.Generator.Emitters;

/// <summary>
/// Emits the {Type}.Analysis nested class with strongly-typed analyzer/tokenizer/filter accessors
/// discovered from the ConfigureAnalysis method.
/// </summary>
internal static class AnalysisNamesEmitter
{
	public static string? Emit(TypeMappingModel model)
	{
		if (!model.AnalysisComponents.HasAnyComponents)
			return null;

		var sb = new StringBuilder();

		EmitHeader(sb);
		EmitNamespace(sb, model);

		return sb.ToString();
	}

	private static void EmitHeader(StringBuilder sb)
	{
		sb.AppendLine("// Licensed to Elasticsearch B.V under one or more agreements.");
		sb.AppendLine("// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.");
		sb.AppendLine("// See the LICENSE file in the project root for more information");
		sb.AppendLine();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
	}

	private static void EmitNamespace(StringBuilder sb, TypeMappingModel model)
	{
		if (!string.IsNullOrEmpty(model.Namespace))
		{
			sb.AppendLine($"namespace {model.Namespace};");
			sb.AppendLine();
		}

		// Handle nested types
		foreach (var containingType in model.ContainingTypes)
		{
			sb.AppendLine($"partial class {containingType}");
			sb.AppendLine("{");
		}

		var indent = new string('\t', model.ContainingTypes.Length);

		// Emit partial class with nested Analysis class
		sb.AppendLine($"{indent}partial class {model.TypeName}");
		sb.AppendLine($"{indent}{{");

		EmitAnalysisClass(sb, indent + "\t", model);

		sb.AppendLine($"{indent}}}");

		// Close nested types
		foreach (var _ in model.ContainingTypes)
			sb.AppendLine("}");
	}

	private static void EmitAnalysisClass(StringBuilder sb, string indent, TypeMappingModel model)
	{
		var components = model.AnalysisComponents;

		sb.AppendLine($"{indent}/// <summary>Analysis component names and accessors for {model.TypeName}.</summary>");
		sb.AppendLine($"{indent}public static class Analysis");
		sb.AppendLine($"{indent}{{");

		// Emit nested accessor classes that extend the base accessor classes
		// These provide both built-in and custom components as instance properties

		// Always emit Analyzers accessor (includes built-ins + custom)
		EmitAnalyzersAccessorClass(sb, indent + "\t", components.Analyzers);

		// Always emit Tokenizers accessor (includes built-ins)
		sb.AppendLine();
		EmitTokenizersAccessorClass(sb, indent + "\t", components.Tokenizers);

		// Always emit TokenFilters accessor (includes built-ins + custom)
		sb.AppendLine();
		EmitTokenFiltersAccessorClass(sb, indent + "\t", components.TokenFilters);

		// Always emit CharFilters accessor (includes built-ins)
		sb.AppendLine();
		EmitCharFiltersAccessorClass(sb, indent + "\t", components.CharFilters);

		// Always emit Normalizers accessor (custom only, no built-ins)
		sb.AppendLine();
		EmitNormalizersAccessorClass(sb, indent + "\t", components.Normalizers);

		sb.AppendLine();

		// Emit static readonly accessor instances
		sb.AppendLine($"{indent}\t/// <summary>Analyzer names (built-in and custom).</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly AnalyzersAccessor Analyzers = new();");
		sb.AppendLine($"{indent}\t/// <summary>Tokenizer names (built-in and custom).</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly TokenizersAccessor Tokenizers = new();");
		sb.AppendLine($"{indent}\t/// <summary>Token filter names (built-in and custom).</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly TokenFiltersAccessor TokenFilters = new();");
		sb.AppendLine($"{indent}\t/// <summary>Char filter names (built-in and custom).</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly CharFiltersAccessor CharFilters = new();");
		sb.AppendLine($"{indent}\t/// <summary>Normalizer names (custom).</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly NormalizersAccessor Normalizers = new();");

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitAnalyzersAccessorClass(
		StringBuilder sb,
		string indent,
		ImmutableArray<AnalysisComponentModel> components
	)
	{
		sb.AppendLine($"{indent}/// <summary>Analyzer accessor with built-in and custom analyzers.</summary>");
		sb.AppendLine($"{indent}public sealed class AnalyzersAccessor : global::Elastic.Mapping.Analysis.AnalyzersAccessor");
		sb.AppendLine($"{indent}{{");

		foreach (var component in components)
		{
			sb.AppendLine($"{indent}\t/// <summary>Custom analyzer: {component.Value}</summary>");
			sb.AppendLine($"{indent}\tpublic string {component.ConstantName} => \"{component.Value}\";");
		}

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitTokenizersAccessorClass(
		StringBuilder sb,
		string indent,
		ImmutableArray<AnalysisComponentModel> components
	)
	{
		sb.AppendLine($"{indent}/// <summary>Tokenizer accessor with built-in and custom tokenizers.</summary>");
		sb.AppendLine($"{indent}public sealed class TokenizersAccessor : global::Elastic.Mapping.Analysis.TokenizersAccessor");
		sb.AppendLine($"{indent}{{");

		foreach (var component in components)
		{
			sb.AppendLine($"{indent}\t/// <summary>Custom tokenizer: {component.Value}</summary>");
			sb.AppendLine($"{indent}\tpublic string {component.ConstantName} => \"{component.Value}\";");
		}

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitTokenFiltersAccessorClass(
		StringBuilder sb,
		string indent,
		ImmutableArray<AnalysisComponentModel> components
	)
	{
		sb.AppendLine($"{indent}/// <summary>Token filter accessor with built-in and custom token filters.</summary>");
		sb.AppendLine($"{indent}public sealed class TokenFiltersAccessor : global::Elastic.Mapping.Analysis.TokenFiltersAccessor");
		sb.AppendLine($"{indent}{{");

		foreach (var component in components)
		{
			sb.AppendLine($"{indent}\t/// <summary>Custom token filter: {component.Value}</summary>");
			sb.AppendLine($"{indent}\tpublic string {component.ConstantName} => \"{component.Value}\";");
		}

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitCharFiltersAccessorClass(
		StringBuilder sb,
		string indent,
		ImmutableArray<AnalysisComponentModel> components
	)
	{
		sb.AppendLine($"{indent}/// <summary>Char filter accessor with built-in and custom char filters.</summary>");
		sb.AppendLine($"{indent}public sealed class CharFiltersAccessor : global::Elastic.Mapping.Analysis.CharFiltersAccessor");
		sb.AppendLine($"{indent}{{");

		foreach (var component in components)
		{
			sb.AppendLine($"{indent}\t/// <summary>Custom char filter: {component.Value}</summary>");
			sb.AppendLine($"{indent}\tpublic string {component.ConstantName} => \"{component.Value}\";");
		}

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitNormalizersAccessorClass(
		StringBuilder sb,
		string indent,
		ImmutableArray<AnalysisComponentModel> components
	)
	{
		sb.AppendLine($"{indent}/// <summary>Normalizer accessor with custom normalizers.</summary>");
		sb.AppendLine($"{indent}public sealed class NormalizersAccessor : global::Elastic.Mapping.Analysis.NormalizersAccessor");
		sb.AppendLine($"{indent}{{");

		foreach (var component in components)
		{
			sb.AppendLine($"{indent}\t/// <summary>Custom normalizer: {component.Value}</summary>");
			sb.AppendLine($"{indent}\tpublic string {component.ConstantName} => \"{component.Value}\";");
		}

		sb.AppendLine($"{indent}}}");
	}
}
