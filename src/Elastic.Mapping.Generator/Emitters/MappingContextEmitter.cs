// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.Security.Cryptography;
using System.Text;
using Elastic.Mapping.Generator.Model;

namespace Elastic.Mapping.Generator.Emitters;

/// <summary>
/// Emits the static Mapping class for a type.
/// </summary>
internal static class MappingContextEmitter
{
	private const int GeneratorMajorVersion = 1;

	public static string Emit(TypeMappingModel model)
	{
		var sb = new StringBuilder();

		EmitHeader(sb);
		EmitNamespace(sb, model);

		return sb.ToString();
	}

	private static void EmitHeader(StringBuilder sb)
	{
		sb.AppendLine("// Licensed to Elasticsearch B.V under one or more agreements.");
		sb.AppendLine("// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.");
		sb.AppendLine("// See the LICENSE file in the project root for more information");
		sb.AppendLine();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
	}

	private static void EmitNamespace(StringBuilder sb, TypeMappingModel model)
	{
		if (!string.IsNullOrEmpty(model.Namespace))
		{
			sb.AppendLine($"namespace {model.Namespace};");
			sb.AppendLine();
		}

		// Handle nested types
		foreach (var containingType in model.ContainingTypes)
		{
			sb.AppendLine($"partial class {containingType}");
			sb.AppendLine("{");
		}

		EmitPartialClass(sb, model);

		// Close nested types
		foreach (var _ in model.ContainingTypes)
			sb.AppendLine("}");
	}

	private static void EmitPartialClass(StringBuilder sb, TypeMappingModel model)
	{
		var indent = new string('\t', model.ContainingTypes.Length);

		sb.AppendLine($"{indent}partial class {model.TypeName}");
		sb.AppendLine($"{indent}{{");

		EmitMappingClass(sb, model, indent + "\t");

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitMappingClass(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var settingsJson = GenerateSettingsJson(model);
		var mappingsJson = GenerateMappingsJson(model);
		var indexJson = GenerateIndexJson(settingsJson, mappingsJson);

		var settingsHash = ComputeHash(settingsJson);
		var mappingsHash = ComputeHash(mappingsJson);
		var combinedHash = ComputeHash(indexJson);

		sb.AppendLine($"{indent}/// <summary>Generated mapping metadata for {model.TypeName}.</summary>");
		sb.AppendLine($"{indent}public static class Mapping");
		sb.AppendLine($"{indent}{{");

		// Hashes
		sb.AppendLine($"{indent}\t/// <summary>Combined hash of settings and mappings (includes generator v{GeneratorMajorVersion}).</summary>");
		sb.AppendLine($"{indent}\tpublic const string Hash = \"{combinedHash}\";");
		sb.AppendLine();
		sb.AppendLine($"{indent}\t/// <summary>Hash of settings JSON only.</summary>");
		sb.AppendLine($"{indent}\tpublic const string SettingsHash = \"{settingsHash}\";");
		sb.AppendLine();
		sb.AppendLine($"{indent}\t/// <summary>Hash of mappings JSON only.</summary>");
		sb.AppendLine($"{indent}\tpublic const string MappingsHash = \"{mappingsHash}\";");
		sb.AppendLine();

		// Strategies
		EmitIndexStrategy(sb, model, indent + "\t");
		EmitSearchStrategy(sb, model, indent + "\t");

		// JSON methods
		EmitJsonMethods(sb, settingsJson, mappingsJson, indexJson, indent + "\t");

		// Fields class
		EmitFieldsClass(sb, model, indent + "\t");

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitIndexStrategy(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine($"{indent}/// <summary>Write target configuration.</summary>");
		sb.AppendLine($"{indent}public static global::Elastic.Mapping.IndexStrategy IndexStrategy => new()");
		sb.AppendLine($"{indent}{{");

		if (model.DataStreamConfig != null)
		{
			var ds = model.DataStreamConfig;
			sb.AppendLine($"{indent}\tDataStreamName = \"{ds.FullName}\",");
			sb.AppendLine($"{indent}\tType = \"{ds.Type}\",");
			sb.AppendLine($"{indent}\tDataset = \"{ds.Dataset}\",");
			sb.AppendLine($"{indent}\tNamespace = \"{ds.Namespace}\",");
		}
		else if (model.IndexConfig != null)
		{
			var idx = model.IndexConfig;
			if (!string.IsNullOrEmpty(idx.WriteAlias))
				sb.AppendLine($"{indent}\tWriteTarget = \"{idx.WriteAlias}\",");
			else if (!string.IsNullOrEmpty(idx.Name))
				sb.AppendLine($"{indent}\tWriteTarget = \"{idx.Name}\",");

			if (!string.IsNullOrEmpty(idx.DatePattern))
				sb.AppendLine($"{indent}\tDatePattern = \"{idx.DatePattern}\",");
		}

		sb.AppendLine($"{indent}}};");
		sb.AppendLine();
	}

	private static void EmitSearchStrategy(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine($"{indent}/// <summary>Search target configuration.</summary>");
		sb.AppendLine($"{indent}public static global::Elastic.Mapping.SearchStrategy SearchStrategy => new()");
		sb.AppendLine($"{indent}{{");

		if (model.DataStreamConfig != null)
		{
			sb.AppendLine($"{indent}\tPattern = \"{model.DataStreamConfig.SearchPattern}\",");
		}
		else if (model.IndexConfig != null)
		{
			var idx = model.IndexConfig;
			if (!string.IsNullOrEmpty(idx.SearchPattern))
				sb.AppendLine($"{indent}\tPattern = \"{idx.SearchPattern}\",");

			if (!string.IsNullOrEmpty(idx.ReadAlias))
				sb.AppendLine($"{indent}\tReadAlias = \"{idx.ReadAlias}\",");
		}

		sb.AppendLine($"{indent}}};");
		sb.AppendLine();
	}

	private static void EmitJsonMethods(StringBuilder sb, string settingsJson, string mappingsJson, string indexJson, string indent)
	{
		// GetSettingsJson
		sb.AppendLine($"{indent}/// <summary>Returns the index settings JSON.</summary>");
		sb.AppendLine($"{indent}public static string GetSettingsJson() =>");
		EmitRawStringLiteral(sb, settingsJson, indent + "\t");
		sb.AppendLine();

		// GetMappingJson
		sb.AppendLine($"{indent}/// <summary>Returns the mappings JSON.</summary>");
		sb.AppendLine($"{indent}public static string GetMappingJson() =>");
		EmitRawStringLiteral(sb, mappingsJson, indent + "\t");
		sb.AppendLine();

		// GetIndexJson
		sb.AppendLine($"{indent}/// <summary>Returns the complete index JSON (settings + mappings).</summary>");
		sb.AppendLine($"{indent}public static string GetIndexJson() =>");
		EmitRawStringLiteral(sb, indexJson, indent + "\t");
	}

	private static void EmitRawStringLiteral(StringBuilder sb, string json, string indent)
	{
		sb.AppendLine($"{indent}\"\"\"");
		foreach (var line in json.Split('\n'))
			sb.AppendLine($"{indent}{line.TrimEnd('\r')}");
		sb.AppendLine($"{indent}\"\"\";");
	}

	private static void EmitFieldsClass(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Field name constants.</summary>");
		sb.AppendLine($"{indent}public static class Fields");
		sb.AppendLine($"{indent}{{");

		foreach (var prop in model.Properties.Where(p => !p.IsIgnored))
			sb.AppendLine($"{indent}\tpublic const string {prop.PropertyName} = \"{prop.FieldName}\";");

		sb.AppendLine($"{indent}}}");
	}

	private static string GenerateSettingsJson(TypeMappingModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("{");
		sb.AppendLine("\t\"settings\": {");

		var idx = model.IndexConfig;
		if (idx != null)
		{
			sb.AppendLine($"\t\t\"number_of_shards\": {idx.Shards},");
			sb.AppendLine($"\t\t\"number_of_replicas\": {idx.Replicas}");

			if (!string.IsNullOrEmpty(idx.RefreshInterval))
			{
				sb.Remove(sb.Length - 1, 1); // Remove newline
				sb.AppendLine(",");
				sb.AppendLine($"\t\t\"refresh_interval\": \"{idx.RefreshInterval}\"");
			}
		}
		else
		{
			sb.AppendLine("\t\t\"number_of_shards\": 1,");
			sb.AppendLine("\t\t\"number_of_replicas\": 1");
		}

		sb.AppendLine("\t}");
		sb.Append("}");

		return sb.ToString();
	}

	private static string GenerateMappingsJson(TypeMappingModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("{");
		sb.AppendLine("\t\"mappings\": {");

		// Dynamic setting
		if (model.IndexConfig != null && !model.IndexConfig.Dynamic)
			sb.AppendLine("\t\t\"dynamic\": false,");

		sb.AppendLine("\t\t\"properties\": {");

		var props = model.Properties.Where(p => !p.IsIgnored).ToList();
		for (var i = 0; i < props.Count; i++)
		{
			var prop = props[i];
			var isLast = i == props.Count - 1;

			sb.Append($"\t\t\t\"{prop.FieldName}\": {{ \"type\": \"{prop.FieldType}\"");

			foreach (var opt in prop.Options)
			{
				var jsonKey = ToSnakeCase(opt.Key);
				sb.Append($", \"{jsonKey}\": {opt.Value}");
			}

			sb.Append(" }");
			sb.AppendLine(isLast ? "" : ",");
		}

		sb.AppendLine("\t\t}");
		sb.AppendLine("\t}");
		sb.Append("}");

		return sb.ToString();
	}

	private static string GenerateIndexJson(string settingsJson, string mappingsJson)
	{
		// Parse and merge settings + mappings
		var sb = new StringBuilder();
		sb.AppendLine("{");

		// Extract settings content
		var settingsContent = ExtractJsonContent(settingsJson, "settings");
		sb.AppendLine($"\t\"settings\": {settingsContent},");

		// Extract mappings content
		var mappingsContent = ExtractJsonContent(mappingsJson, "mappings");
		sb.AppendLine($"\t\"mappings\": {mappingsContent}");

		sb.Append("}");

		return sb.ToString();
	}

	private static string ExtractJsonContent(string json, string key)
	{
		// Simple extraction - find the key and extract its value
		var keyPattern = $"\"{key}\":";
		var startIndex = json.IndexOf(keyPattern);
		if (startIndex < 0)
			return "{}";

		startIndex += keyPattern.Length;

		// Skip whitespace
		while (startIndex < json.Length && char.IsWhiteSpace(json[startIndex]))
			startIndex++;

		// Find matching brace
		var braceCount = 0;
		var endIndex = startIndex;
		for (var i = startIndex; i < json.Length; i++)
		{
			if (json[i] == '{')
				braceCount++;
			else if (json[i] == '}')
			{
				braceCount--;
				if (braceCount == 0)
				{
					endIndex = i + 1;
					break;
				}
			}
		}

		return json.Substring(startIndex, endIndex - startIndex);
	}

	private static string ComputeHash(string content)
	{
		// Include generator major version in hash
		var input = $"v{GeneratorMajorVersion}:{Minify(content)}";
		using var sha = SHA256.Create();
		var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
		return BitConverter.ToString(bytes).Replace("-", "").Substring(0, 16).ToLowerInvariant();
	}

	private static string Minify(string json)
	{
		var sb = new StringBuilder();
		var inString = false;

		for (var i = 0; i < json.Length; i++)
		{
			var c = json[i];

			if (c == '"' && (i == 0 || json[i - 1] != '\\'))
				inString = !inString;

			if (inString || !char.IsWhiteSpace(c))
				sb.Append(c);
		}

		return sb.ToString();
	}

	private static string ToSnakeCase(string name)
	{
		var sb = new StringBuilder();
		for (var i = 0; i < name.Length; i++)
		{
			var c = name[i];
			if (char.IsUpper(c))
			{
				if (i > 0)
					sb.Append('_');
				sb.Append(char.ToLowerInvariant(c));
			}
			else
			{
				sb.Append(c);
			}
		}

		return sb.ToString();
	}
}
