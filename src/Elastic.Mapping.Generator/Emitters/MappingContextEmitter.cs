// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.Security.Cryptography;
using System.Text;
using Elastic.Mapping.Generator.Model;

namespace Elastic.Mapping.Generator.Emitters;

/// <summary>
/// Emits the static ElasticsearchContext class for a type.
/// </summary>
internal static class MappingContextEmitter
{
	private const int GeneratorMajorVersion = 1;

	public static string Emit(TypeMappingModel model)
	{
		var sb = new StringBuilder();

		EmitHeader(sb);
		EmitNamespace(sb, model);

		return sb.ToString();
	}

	private static void EmitHeader(StringBuilder sb)
	{
		sb.AppendLine("// Licensed to Elasticsearch B.V under one or more agreements.");
		sb.AppendLine("// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.");
		sb.AppendLine("// See the LICENSE file in the project root for more information");
		sb.AppendLine();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
	}

	private static void EmitNamespace(StringBuilder sb, TypeMappingModel model)
	{
		if (!string.IsNullOrEmpty(model.Namespace))
		{
			sb.AppendLine($"namespace {model.Namespace};");
			sb.AppendLine();
		}

		// Handle nested types
		foreach (var containingType in model.ContainingTypes)
		{
			sb.AppendLine($"partial class {containingType}");
			sb.AppendLine("{");
		}

		EmitPartialClass(sb, model);

		// Close nested types
		foreach (var _ in model.ContainingTypes)
			sb.AppendLine("}");
	}

	private static void EmitPartialClass(StringBuilder sb, TypeMappingModel model)
	{
		var indent = new string('\t', model.ContainingTypes.Length);

		// Build interface list - IHasElasticsearchContext is always included
		var baseInterface = "global::Elastic.Mapping.IHasElasticsearchContext";

		// Check if we need NET8+ interfaces for static abstract members
		var hasNet8Interfaces = model.HasConfigureAnalysis || model.HasConfigureMappings;

		if (hasNet8Interfaces)
		{
			// Emit conditional compilation for NET8+ interfaces
			sb.AppendLine("#if NET8_0_OR_GREATER");
			EmitClassDeclarationWithInterfaces(sb, model, indent);
			sb.AppendLine("#else");
			sb.AppendLine($"{indent}partial class {model.TypeName} : {baseInterface}");
			sb.AppendLine("#endif");
		}
		else
		{
			// No Configure* methods - just implement base interface
			sb.AppendLine($"{indent}partial class {model.TypeName} : {baseInterface}");
		}

		sb.AppendLine($"{indent}{{");

		// Add the Context property implementing the interface
		EmitContextProperty(sb, model, indent + "\t");

		EmitElasticsearchContextClass(sb, model, indent + "\t");

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitClassDeclarationWithInterfaces(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var interfaces = new List<string> { "global::Elastic.Mapping.IHasElasticsearchContext" };

		if (model.HasConfigureAnalysis && model.HasConfigureMappings && !string.IsNullOrEmpty(model.MappingsBuilderTypeName))
		{
			// Full index configuration: implements IHasIndexConfiguration<TBuilder>
			interfaces.Add($"global::Elastic.Mapping.IHasIndexConfiguration<{model.MappingsBuilderTypeName}>");
		}
		else if (model.HasConfigureAnalysis)
		{
			// Analysis only: implements IHasAnalysisConfiguration
			interfaces.Add("global::Elastic.Mapping.IHasAnalysisConfiguration");
		}
		else if (model.HasConfigureMappings && !string.IsNullOrEmpty(model.MappingsBuilderTypeName))
		{
			// Mappings only: implements IHasMappingsConfiguration<TBuilder>
			interfaces.Add($"global::Elastic.Mapping.IHasMappingsConfiguration<{model.MappingsBuilderTypeName}>");
		}

		sb.AppendLine($"{indent}partial class {model.TypeName} : {string.Join(", ", interfaces)}");
	}

	private static void EmitContextProperty(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine($"{indent}/// <summary>Gets the Elasticsearch context for this type.</summary>");
		sb.AppendLine($"{indent}public static global::Elastic.Mapping.ElasticsearchTypeContext Context => ElasticsearchContext.Instance;");
		sb.AppendLine();
	}

	private static void EmitElasticsearchContextClass(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var settingsJson = GenerateSettingsJson(model);
		var mappingsJson = GenerateMappingsJson(model);
		var indexJson = GenerateIndexJson(settingsJson, mappingsJson);

		var settingsHash = ComputeHash(settingsJson);
		var mappingsHash = ComputeHash(mappingsJson);
		var combinedHash = ComputeHash(indexJson);

		sb.AppendLine($"{indent}/// <summary>Generated Elasticsearch context for {model.TypeName}.</summary>");
		sb.AppendLine($"{indent}public static class ElasticsearchContext");
		sb.AppendLine($"{indent}{{");

		// Static Instance for IHasElasticsearchContext
		sb.AppendLine($"{indent}\t/// <summary>Singleton instance of the context.</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly global::Elastic.Mapping.ElasticsearchTypeContext Instance = new(");
		sb.AppendLine($"{indent}\t\tGetSettingsJson,");
		sb.AppendLine($"{indent}\t\tGetMappingJson,");
		sb.AppendLine($"{indent}\t\tGetIndexJson,");
		sb.AppendLine($"{indent}\t\tHash,");
		sb.AppendLine($"{indent}\t\tSettingsHash,");
		sb.AppendLine($"{indent}\t\tMappingsHash,");
		sb.AppendLine($"{indent}\t\tIndexStrategy,");
		sb.AppendLine($"{indent}\t\tSearchStrategy,");

		// Add ConfigureAnalysis delegate if the type has the method
		if (model.HasConfigureAnalysis)
			sb.AppendLine($"{indent}\t\tConfigureAnalysis: global::{model.FullyQualifiedName}.ConfigureAnalysis");
		else
			sb.AppendLine($"{indent}\t\tConfigureAnalysis: null");

		sb.AppendLine($"{indent}\t);");
		sb.AppendLine();

		// Hashes
		sb.AppendLine($"{indent}\t/// <summary>Combined hash of settings and mappings (includes generator v{GeneratorMajorVersion}).</summary>");
		sb.AppendLine($"{indent}\tpublic const string Hash = \"{combinedHash}\";");
		sb.AppendLine();
		sb.AppendLine($"{indent}\t/// <summary>Hash of settings JSON only.</summary>");
		sb.AppendLine($"{indent}\tpublic const string SettingsHash = \"{settingsHash}\";");
		sb.AppendLine();
		sb.AppendLine($"{indent}\t/// <summary>Hash of mappings JSON only.</summary>");
		sb.AppendLine($"{indent}\tpublic const string MappingsHash = \"{mappingsHash}\";");
		sb.AppendLine();

		// Strategies
		EmitIndexStrategy(sb, model, indent + "\t");
		EmitSearchStrategy(sb, model, indent + "\t");

		// JSON methods
		EmitJsonMethods(sb, settingsJson, mappingsJson, indexJson, indent + "\t");

		// Fields class
		EmitFieldsClass(sb, model, indent + "\t");

		// Field mapping dictionaries for runtime lookup without reflection
		EmitFieldMappingClass(sb, model, indent + "\t");

		// Ignored properties set
		EmitIgnoredProperties(sb, model, indent + "\t");

		// Property map for deserialization
		EmitGetPropertyMap(sb, model, indent + "\t");

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitIndexStrategy(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine($"{indent}/// <summary>Write target configuration.</summary>");
		sb.AppendLine($"{indent}public static global::Elastic.Mapping.IndexStrategy IndexStrategy => new()");
		sb.AppendLine($"{indent}{{");

		if (model.DataStreamConfig != null)
		{
			var ds = model.DataStreamConfig;
			sb.AppendLine($"{indent}\tDataStreamName = \"{ds.FullName}\",");
			sb.AppendLine($"{indent}\tType = \"{ds.Type}\",");
			sb.AppendLine($"{indent}\tDataset = \"{ds.Dataset}\",");
			sb.AppendLine($"{indent}\tNamespace = \"{ds.Namespace}\",");
		}
		else if (model.IndexConfig != null)
		{
			var idx = model.IndexConfig;
			if (!string.IsNullOrEmpty(idx.WriteAlias))
				sb.AppendLine($"{indent}\tWriteTarget = \"{idx.WriteAlias}\",");
			else if (!string.IsNullOrEmpty(idx.Name))
				sb.AppendLine($"{indent}\tWriteTarget = \"{idx.Name}\",");

			if (!string.IsNullOrEmpty(idx.DatePattern))
				sb.AppendLine($"{indent}\tDatePattern = \"{idx.DatePattern}\",");
		}

		sb.AppendLine($"{indent}}};");
		sb.AppendLine();
	}

	private static void EmitSearchStrategy(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine($"{indent}/// <summary>Search target configuration.</summary>");
		sb.AppendLine($"{indent}public static global::Elastic.Mapping.SearchStrategy SearchStrategy => new()");
		sb.AppendLine($"{indent}{{");

		if (model.DataStreamConfig != null)
		{
			sb.AppendLine($"{indent}\tPattern = \"{model.DataStreamConfig.SearchPattern}\",");
		}
		else if (model.IndexConfig != null)
		{
			var idx = model.IndexConfig;
			if (!string.IsNullOrEmpty(idx.SearchPattern))
				sb.AppendLine($"{indent}\tPattern = \"{idx.SearchPattern}\",");

			if (!string.IsNullOrEmpty(idx.ReadAlias))
				sb.AppendLine($"{indent}\tReadAlias = \"{idx.ReadAlias}\",");
		}

		sb.AppendLine($"{indent}}};");
		sb.AppendLine();
	}

	private static void EmitJsonMethods(StringBuilder sb, string settingsJson, string mappingsJson, string indexJson, string indent)
	{
		// GetSettingsJson
		sb.AppendLine($"{indent}/// <summary>Returns the index settings JSON.</summary>");
		sb.AppendLine($"{indent}public static string GetSettingsJson() =>");
		EmitRawStringLiteral(sb, settingsJson, indent + "\t");
		sb.AppendLine();

		// GetMappingJson
		sb.AppendLine($"{indent}/// <summary>Returns the mappings JSON.</summary>");
		sb.AppendLine($"{indent}public static string GetMappingJson() =>");
		EmitRawStringLiteral(sb, mappingsJson, indent + "\t");
		sb.AppendLine();

		// GetIndexJson
		sb.AppendLine($"{indent}/// <summary>Returns the complete index JSON (settings + mappings).</summary>");
		sb.AppendLine($"{indent}public static string GetIndexJson() =>");
		EmitRawStringLiteral(sb, indexJson, indent + "\t");
	}

	private static void EmitRawStringLiteral(StringBuilder sb, string json, string indent)
	{
		sb.AppendLine($"{indent}\"\"\"");
		foreach (var line in json.Split('\n'))
			sb.AppendLine($"{indent}{line.TrimEnd('\r')}");
		sb.AppendLine($"{indent}\"\"\";");
	}

	private static void EmitFieldsClass(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Field name constants.</summary>");
		sb.AppendLine($"{indent}public static class Fields");
		sb.AppendLine($"{indent}{{");

		foreach (var prop in model.Properties.Where(p => !p.IsIgnored))
			sb.AppendLine($"{indent}\tpublic const string {prop.PropertyName} = \"{prop.FieldName}\";");

		sb.AppendLine($"{indent}}}");
	}

	private static string GenerateSettingsJson(TypeMappingModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("{");
		sb.AppendLine("\t\"settings\": {");

		var idx = model.IndexConfig;
		var settingsList = new List<string>();

		// Only emit shards/replicas when explicitly configured (serverless compatibility)
		// Values of -1 mean "not set" and will be omitted
		if (idx != null && idx.Shards > 0)
			settingsList.Add($"\t\t\"number_of_shards\": {idx.Shards}");

		if (idx != null && idx.Replicas >= 0)
			settingsList.Add($"\t\t\"number_of_replicas\": {idx.Replicas}");

		if (idx != null && !string.IsNullOrEmpty(idx.RefreshInterval))
			settingsList.Add($"\t\t\"refresh_interval\": \"{idx.RefreshInterval}\"");

		// Join settings with commas
		sb.AppendLine(string.Join(",\n", settingsList));

		sb.AppendLine("\t}");
		sb.Append("}");

		return sb.ToString();
	}

	private static string GenerateMappingsJson(TypeMappingModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("{");
		sb.AppendLine("\t\"mappings\": {");

		// Dynamic setting
		if (model.IndexConfig != null && !model.IndexConfig.Dynamic)
			sb.AppendLine("\t\t\"dynamic\": false,");

		sb.AppendLine("\t\t\"properties\": {");

		var props = model.Properties.Where(p => !p.IsIgnored).ToList();
		for (var i = 0; i < props.Count; i++)
		{
			var prop = props[i];
			var isLast = i == props.Count - 1;

			sb.Append($"\t\t\t\"{prop.FieldName}\": {{ \"type\": \"{prop.FieldType}\"");

			foreach (var opt in prop.Options)
			{
				var jsonKey = ToSnakeCase(opt.Key);
				sb.Append($", \"{jsonKey}\": {opt.Value}");
			}

			sb.Append(" }");
			sb.AppendLine(isLast ? "" : ",");
		}

		sb.AppendLine("\t\t}");
		sb.AppendLine("\t}");
		sb.Append("}");

		return sb.ToString();
	}

	private static string GenerateIndexJson(string settingsJson, string mappingsJson)
	{
		// Parse and merge settings + mappings
		var sb = new StringBuilder();
		sb.AppendLine("{");

		// Extract settings content
		var settingsContent = ExtractJsonContent(settingsJson, "settings");
		sb.AppendLine($"\t\"settings\": {settingsContent},");

		// Extract mappings content
		var mappingsContent = ExtractJsonContent(mappingsJson, "mappings");
		sb.AppendLine($"\t\"mappings\": {mappingsContent}");

		sb.Append("}");

		return sb.ToString();
	}

	private static string ExtractJsonContent(string json, string key)
	{
		// Simple extraction - find the key and extract its value
		var keyPattern = $"\"{key}\":";
		var startIndex = json.IndexOf(keyPattern);
		if (startIndex < 0)
			return "{}";

		startIndex += keyPattern.Length;

		// Skip whitespace
		while (startIndex < json.Length && char.IsWhiteSpace(json[startIndex]))
			startIndex++;

		// Find matching brace
		var braceCount = 0;
		var endIndex = startIndex;
		for (var i = startIndex; i < json.Length; i++)
		{
			if (json[i] == '{')
				braceCount++;
			else if (json[i] == '}')
			{
				braceCount--;
				if (braceCount == 0)
				{
					endIndex = i + 1;
					break;
				}
			}
		}

		return json.Substring(startIndex, endIndex - startIndex);
	}

	private static string ComputeHash(string content)
	{
		// Include generator major version in hash
		var input = $"v{GeneratorMajorVersion}:{Minify(content)}";
		using var sha = SHA256.Create();
		var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
		return BitConverter.ToString(bytes).Replace("-", "").Substring(0, 16).ToLowerInvariant();
	}

	private static string Minify(string json)
	{
		var sb = new StringBuilder();
		var inString = false;

		for (var i = 0; i < json.Length; i++)
		{
			var c = json[i];

			if (c == '"' && (i == 0 || json[i - 1] != '\\'))
				inString = !inString;

			if (inString || !char.IsWhiteSpace(c))
				sb.Append(c);
		}

		return sb.ToString();
	}

	private static void EmitFieldMappingClass(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var props = model.Properties.Where(p => !p.IsIgnored).ToList();

		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Field name mapping dictionaries.</summary>");
		sb.AppendLine($"{indent}public static class FieldMapping");
		sb.AppendLine($"{indent}{{");

		// PropertyToField
		sb.AppendLine($"{indent}\t/// <summary>Maps C# property name to ES|QL field name.</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, string> PropertyToField = new global::System.Collections.Generic.Dictionary<string, string>");
		sb.AppendLine($"{indent}\t{{");
		foreach (var prop in props)
			sb.AppendLine($"{indent}\t\t[\"{prop.PropertyName}\"] = \"{prop.FieldName}\",");
		sb.AppendLine($"{indent}\t}};");
		sb.AppendLine();

		// FieldToProperty
		sb.AppendLine($"{indent}\t/// <summary>Maps ES|QL field name to C# property name.</summary>");
		sb.AppendLine($"{indent}\tpublic static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, string> FieldToProperty = new global::System.Collections.Generic.Dictionary<string, string>");
		sb.AppendLine($"{indent}\t{{");
		foreach (var prop in props)
			sb.AppendLine($"{indent}\t\t[\"{prop.FieldName}\"] = \"{prop.PropertyName}\",");
		sb.AppendLine($"{indent}\t}};");

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitIgnoredProperties(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var ignored = model.Properties.Where(p => p.IsIgnored).ToList();

		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Property names marked with [JsonIgnore].</summary>");
		sb.Append($"{indent}public static readonly global::System.Collections.Generic.IReadOnlySet<string> IgnoredProperties = ");

		if (ignored.Count == 0)
			sb.AppendLine("new global::System.Collections.Generic.HashSet<string>();");
		else
		{
			sb.AppendLine("new global::System.Collections.Generic.HashSet<string>");
			sb.AppendLine($"{indent}{{");
			foreach (var prop in ignored)
				sb.AppendLine($"{indent}\t\"{prop.PropertyName}\",");
			sb.AppendLine($"{indent}}};");
		}
	}

	private static void EmitGetPropertyMap(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var props = model.Properties.Where(p => !p.IsIgnored).ToList();
		var typeName = model.FullyQualifiedName;

		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Gets PropertyInfo lookup keyed by field name (for deserialization).</summary>");
		sb.AppendLine($"{indent}public static global::System.Collections.Generic.Dictionary<string, global::System.Reflection.PropertyInfo> GetPropertyMap() => new()");
		sb.AppendLine($"{indent}{{");

		foreach (var prop in props)
		{
			// Add by field name
			sb.AppendLine($"{indent}\t[\"{prop.FieldName}\"] = typeof(global::{typeName}).GetProperty(nameof(global::{typeName}.{prop.PropertyName}))!,");

			// Also add by property name if different from field name
			if (prop.PropertyName != prop.FieldName)
				sb.AppendLine($"{indent}\t[\"{prop.PropertyName}\"] = typeof(global::{typeName}).GetProperty(nameof(global::{typeName}.{prop.PropertyName}))!,");

			// Also add by camelCase if different from both field name and property name
			var camelCase = ToCamelCase(prop.PropertyName);
			if (camelCase != prop.FieldName && camelCase != prop.PropertyName)
				sb.AppendLine($"{indent}\t[\"{camelCase}\"] = typeof(global::{typeName}).GetProperty(nameof(global::{typeName}.{prop.PropertyName}))!,");
		}

		sb.AppendLine($"{indent}}};");
	}

	private static string ToCamelCase(string name)
	{
		if (string.IsNullOrEmpty(name))
			return name;

		if (name.Length == 1)
			return name.ToLowerInvariant();

		return char.ToLowerInvariant(name[0]) + name.Substring(1);
	}

	private static string ToSnakeCase(string name)
	{
		var sb = new StringBuilder();
		for (var i = 0; i < name.Length; i++)
		{
			var c = name[i];
			if (char.IsUpper(c))
			{
				if (i > 0)
					sb.Append('_');
				sb.Append(char.ToLowerInvariant(c));
			}
			else
			{
				sb.Append(c);
			}
		}

		return sb.ToString();
	}
}
