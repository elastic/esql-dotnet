// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.Text;
using Elastic.Mapping.Generator.Model;

namespace Elastic.Mapping.Generator.Emitters;

/// <summary>
/// Emits the fluent config builder class for runtime overrides.
/// </summary>
internal static class ConfigBuilderEmitter
{
	public static string Emit(TypeMappingModel model)
	{
		var sb = new StringBuilder();

		EmitHeader(sb);
		EmitNamespace(sb, model);

		return sb.ToString();
	}

	private static void EmitHeader(StringBuilder sb)
	{
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
	}

	private static void EmitNamespace(StringBuilder sb, TypeMappingModel model)
	{
		if (!string.IsNullOrEmpty(model.Namespace))
		{
			sb.AppendLine($"namespace {model.Namespace};");
			sb.AppendLine();
		}

		// Handle nested types
		foreach (var containingType in model.ContainingTypes)
		{
			sb.AppendLine($"partial class {containingType}");
			sb.AppendLine("{");
		}

		EmitPartialClassExtension(sb, model);
		EmitConfigBuilderClass(sb, model);

		// Close nested types
		foreach (var _ in model.ContainingTypes)
			sb.AppendLine("}");
	}

	private static void EmitPartialClassExtension(StringBuilder sb, TypeMappingModel model)
	{
		var indent = new string('\t', model.ContainingTypes.Length);
		var configClassName = $"{model.TypeName}MappingConfig";

		sb.AppendLine($"{indent}partial class {model.TypeName}");
		sb.AppendLine($"{indent}{{");
		sb.AppendLine($"{indent}\t/// <summary>Creates a fluent builder for runtime mapping configuration overrides.</summary>");
		sb.AppendLine($"{indent}\tpublic static {configClassName} MappingConfig() => new();");
		sb.AppendLine($"{indent}}}");
		sb.AppendLine();
	}

	private static void EmitConfigBuilderClass(StringBuilder sb, TypeMappingModel model)
	{
		var indent = new string('\t', model.ContainingTypes.Length);
		var configClassName = $"{model.TypeName}MappingConfig";

		sb.AppendLine($"{indent}/// <summary>Fluent builder for {model.TypeName} mapping configuration with runtime overrides.</summary>");
		sb.AppendLine($"{indent}public sealed class {configClassName}");
		sb.AppendLine($"{indent}{{");

		// Fields for overrides
		sb.AppendLine($"{indent}\tprivate readonly global::System.Collections.Generic.Dictionary<string, global::System.Collections.Generic.Dictionary<string, object?>> _overrides = new();");
		sb.AppendLine();

		// Property methods
		foreach (var prop in model.Properties.Where(p => !p.IsIgnored))
		{
			var configTypeName = GetConfigTypeName(prop.FieldType);
			sb.AppendLine($"{indent}\t/// <summary>Configure the {prop.PropertyName} field.</summary>");
			sb.AppendLine($"{indent}\tpublic {configClassName} {prop.PropertyName}(global::System.Action<{configTypeName}> configure)");
			sb.AppendLine($"{indent}\t{{");
			sb.AppendLine($"{indent}\t\tvar config = new {configTypeName}();");
			sb.AppendLine($"{indent}\t\tconfigure(config);");
			sb.AppendLine($"{indent}\t\t_overrides[\"{prop.FieldName}\"] = config.GetOptions();");
			sb.AppendLine($"{indent}\t\treturn this;");
			sb.AppendLine($"{indent}\t}}");
			sb.AppendLine();
		}

		// GetMappingJson method
		EmitGetMappingJsonMethod(sb, model, indent + "\t");

		// GetSettingsJson method
		sb.AppendLine($"{indent}\t/// <summary>Returns the settings JSON (currently unchanged by overrides).</summary>");
		sb.AppendLine($"{indent}\tpublic string GetSettingsJson() => {model.TypeName}.ElasticsearchContext.GetSettingsJson();");
		sb.AppendLine();

		// GetIndexJson method
		sb.AppendLine($"{indent}\t/// <summary>Returns the complete index JSON with overrides applied.</summary>");
		sb.AppendLine($"{indent}\tpublic string GetIndexJson()");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tvar settings = GetSettingsJson();");
		sb.AppendLine($"{indent}\t\tvar mappings = GetMappingJson();");
		sb.AppendLine($"{indent}\t\treturn MergeJson(settings, mappings);");
		sb.AppendLine($"{indent}\t}}");
		sb.AppendLine();

		// ComputeHash method
		sb.AppendLine($"{indent}\t/// <summary>Computes a hash of the current configuration with overrides.</summary>");
		sb.AppendLine($"{indent}\tpublic string ComputeHash()");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tvar json = GetIndexJson();");
		sb.AppendLine($"{indent}\t\tusing var sha = global::System.Security.Cryptography.SHA256.Create();");
		sb.AppendLine($"{indent}\t\tvar bytes = sha.ComputeHash(global::System.Text.Encoding.UTF8.GetBytes(json));");
		sb.AppendLine($"{indent}\t\treturn global::System.BitConverter.ToString(bytes).Replace(\"-\", \"\").Substring(0, 16).ToLowerInvariant();");
		sb.AppendLine($"{indent}\t}}");
		sb.AppendLine();

		// Helper methods
		EmitHelperMethods(sb, indent + "\t");

		// Emit nested field config classes INSIDE the builder class
		EmitFieldConfigClasses(sb, model, indent + "\t");

		sb.AppendLine($"{indent}}}");
	}

	private static void EmitGetMappingJsonMethod(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine($"{indent}/// <summary>Returns the mappings JSON with overrides applied.</summary>");
		sb.AppendLine($"{indent}public string GetMappingJson()");
		sb.AppendLine($"{indent}{{");
		sb.AppendLine($"{indent}\tif (_overrides.Count == 0)");
		sb.AppendLine($"{indent}\t\treturn {model.TypeName}.ElasticsearchContext.GetMappingJson();");
		sb.AppendLine();
		sb.AppendLine($"{indent}\treturn ApplyOverrides({model.TypeName}.ElasticsearchContext.GetMappingJson());");
		sb.AppendLine($"{indent}}}");
		sb.AppendLine();
	}

	private static void EmitHelperMethods(StringBuilder sb, string indent)
	{
		// ApplyOverrides - use explicit string concatenation to avoid interpolation issues
		sb.AppendLine($"{indent}private string ApplyOverrides(string baseJson)");
		sb.AppendLine($"{indent}{{");
		sb.AppendLine($"{indent}\t// Simple JSON manipulation - in production, use proper JSON parsing");
		sb.AppendLine($"{indent}\tvar result = baseJson;");
		sb.AppendLine($"{indent}\tforeach (var kvp in _overrides)");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tforeach (var opt in kvp.Value)");
		sb.AppendLine($"{indent}\t\t{{");
		sb.AppendLine($"{indent}\t\t\tif (opt.Value == null) continue;");
		sb.AppendLine($"{indent}\t\t\tvar optKey = ToSnakeCase(opt.Key);");
		sb.AppendLine($"{indent}\t\t\tvar optValue = FormatValue(opt.Value);");
		sb.AppendLine(indent + "\t\t\tvar fieldPattern = \"\\\"\" + kvp.Key + \"\\\": { \\\"type\\\":\";");
		sb.AppendLine($"{indent}\t\t\tvar insertPos = result.IndexOf(fieldPattern);");
		sb.AppendLine($"{indent}\t\t\tif (insertPos >= 0)");
		sb.AppendLine($"{indent}\t\t\t{{");
		sb.AppendLine($"{indent}\t\t\t\tvar endBrace = result.IndexOf(\"}}\", insertPos);");
		sb.AppendLine($"{indent}\t\t\t\tif (endBrace > 0)");
		sb.AppendLine(indent + "\t\t\t\t\tresult = result.Insert(endBrace, \", \\\"\" + optKey + \"\\\": \" + optValue);");
		sb.AppendLine($"{indent}\t\t\t}}");
		sb.AppendLine($"{indent}\t\t}}");
		sb.AppendLine($"{indent}\t}}");
		sb.AppendLine($"{indent}\treturn result;");
		sb.AppendLine($"{indent}}}");
		sb.AppendLine();

		// MergeJson - use explicit concatenation
		sb.AppendLine($"{indent}private static string MergeJson(string settings, string mappings)");
		sb.AppendLine($"{indent}{{");
		sb.AppendLine($"{indent}\tvar settingsContent = ExtractContent(settings, \"settings\");");
		sb.AppendLine($"{indent}\tvar mappingsContent = ExtractContent(mappings, \"mappings\");");
		sb.AppendLine(indent + "\treturn \"{\\n\\t\\\"settings\\\": \" + settingsContent + \",\\n\\t\\\"mappings\\\": \" + mappingsContent + \"\\n}\";");
		sb.AppendLine($"{indent}}}");
		sb.AppendLine();

		// ExtractContent - use explicit concatenation
		sb.AppendLine($"{indent}private static string ExtractContent(string json, string key)");
		sb.AppendLine($"{indent}{{");
		sb.AppendLine(indent + "\tvar pattern = \"\\\"\" + key + \"\\\":\";");
		sb.AppendLine($"{indent}\tvar start = json.IndexOf(pattern);");
		sb.AppendLine($"{indent}\tif (start < 0) return \"{{}}\";");
		sb.AppendLine($"{indent}\tstart += pattern.Length;");
		sb.AppendLine($"{indent}\twhile (start < json.Length && char.IsWhiteSpace(json[start])) start++;");
		sb.AppendLine($"{indent}\tvar braceCount = 0;");
		sb.AppendLine($"{indent}\tvar end = start;");
		sb.AppendLine($"{indent}\tfor (var i = start; i < json.Length; i++)");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tif (json[i] == '{{') braceCount++;");
		sb.AppendLine($"{indent}\t\telse if (json[i] == '}}') {{ braceCount--; if (braceCount == 0) {{ end = i + 1; break; }} }}");
		sb.AppendLine($"{indent}\t}}");
		sb.AppendLine($"{indent}\treturn json.Substring(start, end - start);");
		sb.AppendLine($"{indent}}}");
		sb.AppendLine();

		// ToSnakeCase
		sb.AppendLine($"{indent}private static string ToSnakeCase(string name)");
		sb.AppendLine($"{indent}{{");
		sb.AppendLine($"{indent}\tvar sb = new global::System.Text.StringBuilder();");
		sb.AppendLine($"{indent}\tfor (var i = 0; i < name.Length; i++)");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tif (char.IsUpper(name[i]))");
		sb.AppendLine($"{indent}\t\t{{");
		sb.AppendLine($"{indent}\t\t\tif (i > 0) sb.Append('_');");
		sb.AppendLine($"{indent}\t\t\tsb.Append(char.ToLowerInvariant(name[i]));");
		sb.AppendLine($"{indent}\t\t}}");
		sb.AppendLine($"{indent}\t\telse sb.Append(name[i]);");
		sb.AppendLine($"{indent}\t}}");
		sb.AppendLine($"{indent}\treturn sb.ToString();");
		sb.AppendLine($"{indent}}}");
		sb.AppendLine();

		// FormatValue - use explicit concatenation for the string case
		sb.AppendLine($"{indent}private static string FormatValue(object value) =>");
		sb.AppendLine($"{indent}\tvalue switch");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tbool b => b ? \"true\" : \"false\",");
		sb.AppendLine(indent + "\t\tstring s => \"\\\"\" + s + \"\\\"\",");
		sb.AppendLine($"{indent}\t\t_ => value.ToString() ?? \"null\"");
		sb.AppendLine($"{indent}\t}};");
		sb.AppendLine();
	}

	private static void EmitFieldConfigClasses(StringBuilder sb, TypeMappingModel model, string indent)
	{
		// Collect unique config type names (not field types, since multiple field types can share a config)
		var emittedConfigTypes = new HashSet<string>();
		var usedTypes = model.Properties
			.Where(p => !p.IsIgnored)
			.Select(p => p.FieldType)
			.ToList();

		foreach (var fieldType in usedTypes)
		{
			var configTypeName = GetConfigTypeName(fieldType);

			// Skip if we've already emitted this config type
			if (!emittedConfigTypes.Add(configTypeName))
				continue;

			var options = GetOptionsForFieldType(fieldType);

			sb.AppendLine($"{indent}/// <summary>Configuration options for {fieldType} fields.</summary>");
			sb.AppendLine($"{indent}public sealed class {configTypeName}");
			sb.AppendLine($"{indent}{{");
			sb.AppendLine($"{indent}\tprivate readonly global::System.Collections.Generic.Dictionary<string, object?> _options = new();");
			sb.AppendLine();

			foreach (var opt in options)
			{
				var paramType = GetOptionParamType(opt);
				sb.AppendLine($"{indent}\t/// <summary>Sets the {opt} option.</summary>");
				sb.AppendLine($"{indent}\tpublic {configTypeName} {opt}({paramType} value) {{ _options[\"{opt}\"] = value; return this; }}");
				sb.AppendLine();
			}

			sb.AppendLine($"{indent}\tinternal global::System.Collections.Generic.Dictionary<string, object?> GetOptions() => _options;");
			sb.AppendLine($"{indent}}}");
			sb.AppendLine();
		}
	}

	private static string GetConfigTypeName(string fieldType) =>
		fieldType switch
		{
			FieldTypes.Text => "TextFieldConfig",
			FieldTypes.Keyword => "KeywordFieldConfig",
			FieldTypes.Date => "DateFieldConfig",
			FieldTypes.Long or FieldTypes.Integer or FieldTypes.Short or FieldTypes.Byte => "NumericFieldConfig",
			FieldTypes.Double or FieldTypes.Float => "NumericFieldConfig",
			FieldTypes.Boolean => "BooleanFieldConfig",
			FieldTypes.Nested => "NestedFieldConfig",
			FieldTypes.Object => "ObjectFieldConfig",
			FieldTypes.Ip => "IpFieldConfig",
			FieldTypes.GeoPoint => "GeoPointFieldConfig",
			FieldTypes.GeoShape => "GeoShapeFieldConfig",
			FieldTypes.Completion => "CompletionFieldConfig",
			FieldTypes.DenseVector => "DenseVectorFieldConfig",
			FieldTypes.SemanticText => "SemanticTextFieldConfig",
			_ => "GenericFieldConfig"
		};

	private static string[] GetOptionsForFieldType(string fieldType) =>
		fieldType switch
		{
			FieldTypes.Text => ["Analyzer", "SearchAnalyzer", "Norms", "Index"],
			FieldTypes.Keyword => ["Normalizer", "IgnoreAbove", "DocValues", "Index"],
			FieldTypes.Date => ["Format", "DocValues", "Index"],
			FieldTypes.Long or FieldTypes.Integer or FieldTypes.Short or FieldTypes.Byte => ["DocValues", "Index"],
			FieldTypes.Double or FieldTypes.Float => ["DocValues", "Index"],
			FieldTypes.Boolean => ["DocValues", "Index"],
			FieldTypes.Nested => ["IncludeInParent", "IncludeInRoot"],
			FieldTypes.Object => ["Enabled"],
			FieldTypes.Ip => ["DocValues", "Index"],
			FieldTypes.GeoPoint => ["DocValues", "Index"],
			FieldTypes.GeoShape => ["DocValues", "Index"],
			FieldTypes.Completion => ["Analyzer", "SearchAnalyzer"],
			FieldTypes.DenseVector => ["Dims", "Similarity"],
			FieldTypes.SemanticText => ["InferenceId"],
			_ => []
		};

	private static string GetOptionParamType(string optionName) =>
		optionName switch
		{
			"IgnoreAbove" or "Dims" => "int",
			"Norms" or "DocValues" or "Index" or "Enabled" or "IncludeInParent" or "IncludeInRoot" => "bool",
			_ => "string"
		};
}
